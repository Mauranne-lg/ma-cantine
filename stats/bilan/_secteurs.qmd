
# Focus par secteurs

Nous nous int√©ressions √† la r√©partition des t√©l√©d√©claration en fonction des secteurs principaux et secondaires, pour la campagne sur les donn√©es 2023. Nous utilisons la strat√©gie **Je Ne Sais Pas** pour le traitement des valeurs manquantes.

::: {.callout-note}
Les cuisines centrales ont √©t√© supprim√©es car elles cumulent plusieurs secteurs (`central` et `central_serving`)
:::

```{python}
# | echo: false
# | output: asis

def traitement_secteurs(tds, year):
    df = tds[year].copy()

     
    if tds[year]['year'].max() != 2022:  # Transform the dict into a list of category
        df["canteen.sectors_"] = df["canteen.sectors"].fillna('[]')
        df["canteen.sectors_"] = df["canteen.sectors_"].apply(lambda x: [item["name"] for item in ast.literal_eval(x)])
    else:
        df["canteen.sectors_"] = df["canteen.sectors"].fillna('')
        df["canteen.sectors_"] = df["canteen.sectors_"].apply(lambda x: x.split(","))

    # Process all central kitchen as one sector
    df['canteen.sectors_'] = df['canteen.sectors_'].apply(lambda x: ['Secteurs multiples'] if str(x).count(',') > 0 else x)
    df['canteen.sectors_'].to_csv('sectors.csv')

    # Explode the lists into separate rows
    df_exploded = df.explode("canteen.sectors_")

    # Use get_dummies to create dummy columns for each category
    categories_dummies = pd.get_dummies(df_exploded["canteen.sectors_"])

    # Group by the index (items) and sum the dummy columns
    categories_dummies_grouped = categories_dummies.groupby(by=categories_dummies.index).sum()
    
    # Concatenate the dummy columns with the original DataFrame
    df_normalized = pd.concat([df, categories_dummies_grouped], axis=1)

    # Drop the 'categories' column since we have the dummies
    df_normalized = df_normalized.drop(columns=["canteen.sectors_"])

    return df_normalized

def calcul_indicateurs_secteurs(tds, year, suffix=''):
    sectors = {}
    sectors[year] = {}
    df_processed_sectors = traitement_secteurs(tds, year)

    # Clearing out central kitchen as they have multiple sectors
    # TODO : les inclure sous une nouvelle cat√©gorie

    for cat in utils.SECTORS.keys():
        sectors[year][cat] = {}
        if cat in df_processed_sectors.columns:
            df_cat = df_processed_sectors[df_processed_sectors[cat] > 0]
            sectors[year][cat][f'Nombre de TD{suffix}'] = df_cat[cat].sum()
            sectors[year][cat][f'Taux des TD pris en compte{suffix}'] = len(df_cat[cat])/len(tds[year])
            sectors[year][cat][f'Montant total des achats{suffix}'] = df_cat["teledeclaration.value_total_ht"].sum()
            sectors[year][cat][f'Taux des achats Bio{suffix}'] = df_cat["teledeclaration.value_bio_ht"].sum()/df_cat["teledeclaration.value_total_ht"].sum()
            sectors[year][cat][f'Montant des achats Bio{suffix}'] = df_cat["teledeclaration.value_bio_ht"].sum()
            sectors[year][cat][f'Taux achats secteurs{suffix}'] = df_cat["teledeclaration.value_total_ht"].sum()/ tds[year]["teledeclaration.value_total_ht"].sum()

    summary = pd.DataFrame.from_dict(sectors[year]).T

    # Ajout des cat√©gories pour caract√©riser chaque sous-cat√©gorie
    summary['sector'] = summary.index.map(utils.SECTORS)
    summary = summary.reset_index(names='sub_sector')

    # Calcul des totaux par secteurs
    summary_by_sector = summary.groupby(['sector']).sum()
    summary_by_sector['sub_sector'] = ['Total (somme)'] * len(summary_by_sector)
    summary_by_sector = summary_by_sector.reset_index(names='sector')

    # Agregation des sous secteur et secteurs
    summary_by_sub_sector = pd.concat([summary, summary_by_sector])
    summary_by_sub_sector = summary_by_sub_sector.groupby(['sector', 'sub_sector']).sum()

    # TODO  A optimiser : Actuellement nous recalculons tous les taux car ils ont √©t√© corrompus par l'aggr√©gation en somme
    summary_by_sub_sector[f'Taux des achats Bio{suffix}'] = summary_by_sub_sector.apply(lambda x: x[f'Montant des achats Bio{suffix}'] / x[f'Montant total des achats{suffix}'], axis=1)
    summary_by_sub_sector[f'Taux achats secteurs{suffix}'] = summary_by_sub_sector.apply(lambda x: x[f'Montant total des achats{suffix}'] / tds[year]["teledeclaration.value_total_ht"].sum(), axis=1)

    # Suppression des colonnes apr√®s leur utilisation pour les calculs de ratio
    del summary_by_sub_sector[f'Montant total des achats{suffix}']
    del summary_by_sub_sector[f'Montant des achats Bio{suffix}']

    return summary_by_sub_sector
```

## üì∑ 2022
```{python}
# | echo: false
# | output: asis

summary = calcul_indicateurs_secteurs(tds, 'Campagne 2022')
utils.display_indicateurs(summary, transpose=False)
```

## üì∑ 2023
```{python}
# | echo: false
# | output: asis

summary = calcul_indicateurs_secteurs(tds, 'Campagne 2023')

def display_sub_sector(summary, sector):
    summary_sector = summary[summary.index.isin([sector], level=0)].copy()
    summary_sector = summary_sector.reset_index(0)
    del summary_sector['sector']
    summary_sector.index = summary_sector.index.set_names('Sous Secteur')
    utils.display_indicateurs(summary_sector, transpose=False)

print('### Enseignement')
display_sub_sector(summary, 'education')

print('### M√©dico Social')
display_sub_sector(summary, 'social')

print('### Sant√©')
display_sub_sector(summary, 'health')

print('### Administration')
display_sub_sector(summary, 'administration')

print('### Multi Secteurs')
display_sub_sector(summary, 'multiple_sectors')

```

## ‚öñÔ∏è Comparaison isop√©rim√®tre
```{python}
# | echo: false
# | output: asis
summary_2022 = calcul_indicateurs_secteurs(tds_commun, 'Campagne 2022', suffix=' 2022')
summary_2023 = calcul_indicateurs_secteurs(tds_commun, 'Campagne 2023', suffix=' 2023')
summary = pd.concat([summary_2022, summary_2023], axis=1)
utils.display_indicateurs(summary, transpose=False)

```
```{python}
# | echo: false
# | output: asis

def display_sub_sector(summary, sector):
    summary_sector = summary[summary.index.isin([sector], level=0)].copy()
    summary_sector = summary_sector.reset_index(0)
    del summary_sector['sector']
    summary_sector.index = summary_sector.index.set_names('Sous Secteur')
    utils.display_indicateurs(summary_sector, transpose=False)

print('### Enseignement')
display_sub_sector(summary, 'education')

print('### M√©dico Social')
display_sub_sector(summary, 'social')

print('### Sant√©')
display_sub_sector(summary, 'health')

print('### Administration')
display_sub_sector(summary, 'administration')

print('### Multi Secteurs')
display_sub_sector(summary, 'multiple_sectors')

```